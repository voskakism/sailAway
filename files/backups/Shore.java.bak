class Shore extends LinearSegment
{
	private Coordinates a;
	private Coordinates b;
	
	private double minX;
	private double minY;
	private double maxX;
	private double maxY;
	
	Shore(Coordinates a, Coordinates b)
	{
		this.a = a;
		this.b = b;
		
		determineExtremes();
		determineSlope();
		determineIntercept();
		//determineLength();
	}
	
	public Coordinates getPointA(){return a;}
	public Coordinates getPointB(){return b;}
	
	public Coordinates getNorthEnd(){return northEnd;}
	public Coordinates getSouthEnd(){return southEnd;}
	public Coordinates getWestEnd(){return westEnd;}
	public Coordinates getEastEnd(){return eastEnd;}
	
	public boolean isFlat()
	{
		if(isVertical) return false;
		if(slope == 0) return true;
		return false;
	}
	
	protected void determineExtremes()
	{
		if(a.getLongitude() <= b.getLongitude()){
			westEnd = a;
			eastEnd = b;
		}else{
			westEnd = b;
			eastEnd = a;
		}
		if(a.getLatitude() <= b.getLatitude()){
			southEnd = a;
			northEnd = b;
		}else{
			southEnd = b;
			northEnd = a;
		}
		
		if(AppConfiguration.DEBUG){
			System.out.println("Shore NSWE extremes are:");
			System.out.println("N-end: " + northEnd.toString());
			System.out.println("S-end: " + southEnd.toString());
			System.out.println("W-end: " + westEnd.toString());
			System.out.println("E-end: " + eastEnd.toString());
			//System.out.println("Shore length: " + length);
		}
		
		minX = westEnd.getLongitude();
		maxX = eastEnd.getLongitude();
		minY = southEnd.getLatitude();
		maxY = northEnd.getLatitude();
	}
	
	protected void determineSlope()
	{
		if(a.getLongitude() == b.getLongitude()){
			isVertical = true;
			// Slope is infinite
		}else{
			isVertical = false;
			slope = (a.getLatitude() - b.getLatitude()) / (a.getLongitude() - b.getLongitude());
		}
		
		if(AppConfiguration.DEBUG){
			if(isVertical){
				System.out.println("Shore is vertical");
			} else{
				System.out.println("Shore slope is " + slope);
			}
			if(isFlat()) System.out.println("Shore is flat");
		}
	}
	
	protected void determineIntercept()
	{
		if(isVertical){
			// Intercept not applicable
		}else{
			intercept = a.getLatitude() - slope * a.getLongitude();
		}
	}
	
	/*protected void determineLength()
	{
		if(isVertical){
			length = northEnd.getLatitude() - southEnd.getLatitude();
		} else{
			double horizontalDiff = b.getLongitude() - a.getLongitude();
			double verticalDiff = b.getLatitude() - a.getLatitude();
			length = Math.sqrt(Math.pow(horizontalDiff, 2) + Math.pow(verticalDiff, 2));
		}
	}*/
	
	public boolean intersects(Shore s)
	{
		if(!((this.isVertical) || (s.isVertical))){
			if(this.slope == s.slope){
				if(this.intercept == s.intercept){ // colinear shores i.e., on the same carrier line
					/* If the sum of their respective lengths is bigger than the length of the linear segment that is defined by endpoints
					 * M: (xm, ym = slope * xn + intercept) and 
					 * N: (xn, yn = slope * xn + intercept) ##NOTE: in this case, both slope and intercept are common for the two shores##, where
					 * M is the western-most point and
					 * N is the eastern-most point of the union set of the points in the two shores,
					 * then the shores intersect, since they have a mutually overlapping section.
					 *
					 * Note that since the slope is common, we need not calculate length, but simply get either the two vertical or two horizontal
					 * components of the shores (here, the horizontals are selected arbitrarily). All three compared lengths remain proportional, since:
					 * φ = Arctan(slope) and
					 * horizontal component (i.e adjacent) = hypotenuse (i.e shore length) / cos(φ).
					 * in the other shore's triangle, the horizontal component is calculated by dividing with the exact same number, cos(φ).
					 * The same applies to the "triangle of unions" discussed earlier.
					 */
					double westernmostLon = this.minX;
					if(s.minX < westernmostLon){
						westernmostLon = s.minX;
					}
					double easternmostLon = this.maxX;
					if(s.maxX > easternmostLon){
						easternmostLon = s.maxX;
					}
					double combinedHorizontalSpan = easternmostLon - westernmostLon;
					if(combinedHorizontalSpan > ((this.maxX - this.minX) + (s.maxX - s.minX))){
						return false;
					} else{
						return true;
					}
				} else{
					return false; // parallel segments and not colinear
				}
			} else{ // Different slope
				// Find intersection point
				double longitudeOfIntersection = (s.intercept - this.intercept) / (this.slope - s.slope);
				double latitudeOfIntersection = this.slope * longitudeOfIntersection + this.intercept;
				// Check that the intersection point is within both the linear segments' boundaries.
				/* Note that since these linear funtions are genuinely monotonous and thus 1-1 functions,
				 * if A and B the endpoints of a linear segment, with coordinates:
				 * A: (xA, f(xA) = yA)
				 * B: (xB, f(xB) = yB)
				 * and there is a point Z that belongs to the segment's line with coordinates:
				 * Z: (xZ, f(xZ) = yZ)
				 * and (xA <= xZ <= xB) <=> (yA <= yZ <= yB).
				 * So we need not check both the horizontal (longitudinal) and vertical (latitudinal) boundaries of a segment.
				 * We have chosen to examine the horizontal boundaries for both linear segments.
				 */
				if(!((this.isFlat()) || (s.isFlat()))){
					if((this.minX < longitudeOfIntersection) && (this.maxX > longitudeOfIntersection)){
						if((s.minX < longitudeOfIntersection) && (s.maxX > longitudeOfIntersection)){
							/*if((this.minY < latitudeOfIntersection) && (this.maxY > latitudeOfIntersection)){ // The latitude checks are redundant, but we were getting false positives for an unknown reason (perhaps implicit number conversions / rounding).
								/*if((s.minY < latitudeOfIntersection) && (s.maxY > latitudeOfIntersection)){ // Checking further with latitude seems to have gotten it fixed.
									return true;
								} else{
									return false;
								}
							} else {
								return false;
							}*/
							return true;
						} else{
							return false;
						}
					} else{
						return false;
					}
				} else if(((!(this.isFlat())) && (s.isFlat())) || ((this.isFlat()) && (!(s.isFlat())))){
					System.out.println("1 of 2 flat");///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
					if(this.isFlat()){
						System.out.println("This is flat");//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						return flatAndSlopedIntersection(this, s, longitudeOfIntersection);
					} else{
						System.out.println("The other is flat");/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						return flatAndSlopedIntersection(s, this, longitudeOfIntersection);
					}
				}
				/*else{ // Both are flat. This branch should be unreachable since the "equal slope" case above should handle it. Java requires that boolean methods with branching always return, hence the forced "else" here.
					System.out.println("This should never print1");
					return true;
				}*/
			}
		}else if(((this.isVertical) && (!(s.isVertical))) || ((!(this.isVertical)) && (s.isVertical))){
			if(this.isVertical){
				return verticalAndSlopedIntersection(this, s);
			} else{
				return verticalAndSlopedIntersection(s, this);
			}
		} else{
			if(this.a.getLongitude() == s.a.getLongitude()){ // colinear shores i.e., on the same (vertical) carrier line
				/* We determine occurence of overlap by comparing lengths as done earlier in the method.
				 * Note that in this case, the vertical component is the same as length and horizontal is zero.
				 */
				 
				double southernmostLat = this.minY;
				if(s.minY < southernmostLat){
					southernmostLat = s.minY;
				}
				double northernmostLat = this.maxY;
				if(s.maxY > northernmostLat){
					northernmostLat = s.maxY;
				}
				double combinedVerticalSpan = northernmostLat - southernmostLat;
				if(combinedVerticalSpan > ((this.maxY - this.minY) + (s.maxY - s.minY))){
					return false;
				} else{
					return true;
				}
			} else{
				return false; // parallel segments and not colinear
			}
		}
		System.out.println("This should never print2");
		return true;
	}
	
	public boolean intersectsAdjacent(Shore s)
	{
		if(!((this.isVertical) || (s.isVertical))){
			if(this.slope == s.slope){
				double westernmostLon = this.minX;
				if(s.minX < westernmostLon){
					westernmostLon = s.minX;
				}
				double easternmostLon = this.maxX;
				if(s.maxX > easternmostLon){
					easternmostLon = s.maxX;
				}
				double combinedHorizontalSpan = easternmostLon - westernmostLon;
				if((combinedHorizontalSpan + 0.001) > ((this.maxX - this.minX) + (s.maxX - s.minX))){ // we have to cheat a little here, by adding an offset...
					return false;
				} else{
					return true;
				}
			} else{
				return false;
			}
		} else if(((this.isVertical) && (!(s.isVertical))) || ((!(this.isVertical)) && (s.isVertical))){
			return false;
		} else{
			double southernmostLat = this.minY;
			if(s.minY < southernmostLat){
				southernmostLat = s.minY;
			}
			double northernmostLat = this.maxY;
			if(s.maxY > northernmostLat){
				northernmostLat = s.maxY;
			}
			double combinedVerticalSpan = northernmostLat - southernmostLat;
			if((combinedVerticalSpan + 0.001) > ((this.maxY - this.minY) + (s.maxY - s.minY))){
				return false;
			} else{
				return true;
			}
		}
	}
	
	private static boolean verticalAndSlopedIntersection(Shore v, Shore s)
	{
		if((s.minX <= v.a.getLongitude()) && (s.maxX >= v.a.getLongitude())){
			//find intersection
			double latitudeOfIntersection = s.slope * v.a.getLongitude() + s.intercept;
			//and check vertical's latitude boundaries
			if((v.minY < latitudeOfIntersection) && (v.maxY > latitudeOfIntersection)){
				return true;
			} else{
				return false;
			}
		} else{
			return false;
		}
	}
	
	// This method is a bit different, functionally, from the similar verticalAndSlopedIntersection(), as it does not calculate the intersection point,
	// but it receives it as an argument (double lonOfIntersection) from its caller, intersects().
	private static boolean flatAndSlopedIntersection(Shore f, Shore s, double lonOfIntersection)
	{
		if((f.minX < lonOfIntersection) && (f.maxX > lonOfIntersection)){
			if((s.minX < lonOfIntersection) && (s.maxX > lonOfIntersection)){
				return true;
			} else{
				return false;
			}
		} else{
			return false;
		}
	}
	
	public String print()
	{
		return ("Shore with endpoints: A: " + a.toString() + " and B: " + b.toString());
	}
}