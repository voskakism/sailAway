import java.util.List;
import java.util.LinkedList;
import java.util.ListIterator;
import java.util.Random;

class Lnav
{
	//private boolean underWay = true;
	private final int BROADCAST_INTERVAL = 2000; //milliseconds
	
	//Vessel Info
	private Vessel vessel;
	/*private long mmsi;
	private String flag;
	private String name;
	private String type;
	private double length;
	private double width;
	private double draught;*/
	
	//Trip Info
	private Azimuth heading;
	private double speed;
	private double maxSpeed;
	private double minSpeed;
	private double laneWidth;
	private double colliderRadius;
	private double turbulence;
	
	//Vessel's Current Position
	//private Coordinates position;
	
	//Route Waypoints
	List<Coordinates> waypoints;
	
	Lnav(Vessel vessel, TripParameters parameters, List<Coordinates> route)
	{
		//Set Vessel Info
		this.vessel = vessel;
		/*mmsi = vessel.getMmsi();
		flag = vessel.getFlag();
		name = vessel.getName();
		type = vessel.getType();
		length = vessel.getLength();
		width = vessel.getWidth();
		draught = vessel.getDraught();*/
		
		//Set Trip Info
		heading = parameters.getInitialHeading();
		speed = parameters.getInitialSpeed();
		maxSpeed = parameters.getMaximumSpeed();
		minSpeed = parameters.getMinimumSafeSpeed();
		laneWidth = parameters.getLaneWidth();
		colliderRadius = parameters.getColliderRadius();
		turbulence = parameters.getTurbulence();

		//Set Route
		waypoints = route;
	}
	
	public void go()
	{
		ListIterator<Coordinates> iterator = waypoints.listIterator();
		Coordinates position = iterator.next();
		Azimuth bearing;
		Coordinates nextWaypoint;
		double step, distanceToWaypoint, cap, legLength, waveHit;
		Random random = new Random(System.currentTimeMillis());
		while(iterator.hasNext()){
			nextWaypoint = iterator.next();
			System.out.println("Next waypoint is: (" + nextWaypoint.getLongtitude() + ", " + nextWaypoint.getLatitude() + ")");//////////////////////////////////////////////////////////////
			bearing = Coordinates.calculateBearing(position, nextWaypoint);
			legLength = determineLegLength(iterator, nextWaypoint);
			System.out.println("LEG LENGTH: " + legLength);//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			cap = determineSpeedCap(iterator, nextWaypoint, bearing);
			System.out.println("CAP: " + cap);///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			do{
				distanceToWaypoint = Coordinates.calculateDistance(position, nextWaypoint);
				System.out.println("DISTANCE TO WAYPOINT: " + distanceToWaypoint);///////////////////////////////////////////////////////////////////////////////////////////////////////////
				//speed = 0.2;///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				determineSpeed(cap, distanceToWaypoint, legLength);
				// calculate a slightly randomized heading, take turbulence into account...
				waveHit = (random.nextInt(41) - 20) * turbulence;
				if(waveHit < 0){
					heading.rotateCounterClockwise(Math.abs(waveHit));
				} else{
					heading.rotateClockwise(waveHit);
				}
				
				//heading = bearing; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				step = speed * BROADCAST_INTERVAL / 1000;
				
				position.move(heading, step);
				bearing = Coordinates.calculateBearing(position, nextWaypoint);
				heading.turnTo(bearing, 0.8);
				AISBroadcast ais = new AISBroadcast(System.currentTimeMillis(), this.vessel, position, heading, speed);
				ais.toConsole();
				//don't forget to send to Esper
				
				try{
					Thread.sleep(BROADCAST_INTERVAL);
				} catch(InterruptedException ie){
					ie.printStackTrace();
				}
			}while(distanceToWaypoint > colliderRadius);
			System.out.println("Reached waypoint: (" + nextWaypoint.getLongtitude() + ", " + nextWaypoint.getLatitude() + ")");
		}
		System.out.println("Reached destination.");
	}
	
	private double determineSpeedCap(ListIterator<Coordinates> iterator, Coordinates nextWaypoint, Azimuth currentBearing)
	{
		double speedCap;
		if(iterator.hasNext()){
			Coordinates waypointAfterTheNext = iterator.next();
			System.out.println("Upcoming waypoint beyond the next: LON " + waypointAfterTheNext.getLongtitude() + " LAT " + waypointAfterTheNext.getLatitude());/////////////////////////////
			Azimuth nextBearing = Coordinates.calculateBearing(nextWaypoint, waypointAfterTheNext);
			double turn = Math.abs(nextBearing.getAzimuth() - currentBearing.getAzimuth());
			if(turn > 180){
				turn = 360 - turn;
			}
			System.out.println("Next turn is angled: " + turn);//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			speedCap = maxSpeed * (1 - (turn / 180));
			if(speedCap < minSpeed){
				speedCap = minSpeed;
			}
			iterator.previous(); //to reset the cursor position to the nextWaypoint
			return speedCap;
		} else{
			System.out.println("No waypoints beyond the next.");/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			speedCap = minSpeed * 1 / 3;
			return speedCap;
		}
	}
	
	private void determineSpeed(double cap, double distanceToWaypoint, double legLength)
	{
		double threshold = legLength * (1 - (cap / maxSpeed)) * 1.25;
		if(distanceToWaypoint < threshold){//if in braking radius
			System.out.println("IN BRAKING RADIUS");/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			convergeSpeedTo(cap, 0.06, 0.095);
		} else{
			convergeSpeedTo(maxSpeed, 0.06, 0.095);
		}
	}
	
	private double determineLegLength(ListIterator<Coordinates> iterator, Coordinates endOfLeg)
	{
		// ListIterator.next() returns the element pointed by the cursor and then advances the cursor
		// ListIterator.previous() recedes the cursor and then returns the element pointed at by the cursor
		iterator.previous();
		Coordinates startOfLeg = iterator.previous();
		iterator.next();
		iterator.next();
		
		System.out.println("startOfleg " + startOfLeg.getLongtitude() + " " + startOfLeg.getLatitude());/////////////////////////////////////////////////////////////////////////////////////
		System.out.println("endOfleg " + endOfLeg.getLongtitude() + " " + endOfLeg.getLatitude());///////////////////////////////////////////////////////////////////////////////////////////
		return (Coordinates.calculateDistance(startOfLeg, endOfLeg));
		
	}
	
	private void convergeSpeedTo(double target, double acceleration, double decceleration)
	{
		double diff = target - speed;
		if(diff > 0){
			speed += (diff) * acceleration;
		} else{
			speed += (diff) * decceleration;
		}
	}
	
	/*public void endTrip()
	{
		underWay = false;
	}*/
}