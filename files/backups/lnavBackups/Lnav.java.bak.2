import java.util.LinkedList;
import java.util.ListIterator;
import java.util.Iterator;
import java.util.Random;
import com.espertech.esper.client.EPServiceProvider;

class Lnav implements Runnable
{
	//private boolean underWay = true;
	private final int BROADCAST_INTERVAL = AppConfiguration.getBroadcastInterval(); //milliseconds
	private final int COLLIDER_RADIUS = (AppConfiguration.getLaneWidth() / 2);
	private final int DESTINATION_RADIUS = 10;
	//private final double SPEED_TOLERANCE = 0.5;/////////////////////////////////////////////////////////////////////////////////
	
	private Vessel vessel;
	private TripParameters parameters;
	private Itinerary route;
	private Terrain map;
	private EPServiceProvider engine;
	
	//Trip Info
	private Azimuth heading;
	private double speed;
	private double maxSpeed;
	private double minSpeed;
	private double laneWidth;
	private double turbulence;
	
	Lnav(Vessel vessel, TripParameters parameters, Itinerary route, Terrain map, EPServiceProvider engine)
	{
		//System.out.println("DEBUG: In Lnav Constructor");//////////////////////////////////////////////////////////////
		this.vessel = vessel;
		this.parameters = parameters;
		this.route = route;
		this.map = map;
		this.engine = engine;
		
		// total mass calculation
		double weight = vessel.getWeight();
		double ballast = parameters.getBallast();
		double fuel = parameters.getFuel();
		double payload = parameters.getPayload();
		double mass = weight + ballast + fuel + payload; // assuming constant gravity acceleration (let g = 10 m/s^2) at sea level (at the Aegean and devoid of lunar tide), same weights correspond to equal masses.
		
		// set speed caps for turns.
		LinkedList<Leg> legs = route.getLegs();
		ListIterator<Leg> li = legs.listIterator();
		// 1st pass: calculate speed limits of each turn 'myopically' based the turn alone.
		// The ships follow uniform circular motion when taking a turn. Consequently, angular acceleration is zero, angular velocity, speed (linear, tangential), circle's center (a.k.a. "turnpoint") and turn radius are all constant for each turn.
		// In such motion, the formula for centripetal acceleration is given by: ac = v^2 / r , where: ac = centripetal acceleration, v = speed, r = turn radius. Multiplying the equation with mass,
		// Fc  = v^2 * m / r , where Fc = centripetal force, m = mass (Newton's 2nd Law of Motion). We solve for speed. Fc is an app-wide extra-systemic constant.
		// The speed limit refers to the (maximum for the turn) linear speed of the ship and it is as a scalar, not a vector.
		double centripetalForce = AppConfiguration.getCentripetalForce(); /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		do{
			Leg currentLeg = li.next();
			Waypoint wb = (Waypoint)currentLeg.getPointB();
			Turn t = wb.getTurn();
			if(t == null) continue;
			double turnRadius = t.getTurnRadius();
			double cap = Math.sqrt(centripetalForce * turnRadius / mass);
			t.setSpeedCap(cap);
		} while(li.hasNext());
		// 2nd pass: where needed, update the speed limits of turns so that they take into consideration the speed limits of other turns ahead that are very close, as in an "S" pair of turns.
		//
		
		double carryOverSpd = -1;
		int round = 0;
		double decel = vessel.getDeceleration();
		double maxSpd = vessel.getMaximumSpeed();
		Iterator<Leg> di = legs.descendingIterator(); // REVERSE iterator: The first element to be gotten here, is the route's last leg
		di.next(); // skip last leg
		while(di.hasNext()){
			round++;
			Leg currentLeg = di.next();
			Waypoint wb = (Waypoint)currentLeg.getPointB();
			Turn t = wb.getTurn();
			if(t == null) break; // unlikely. all Legs but the last have a Turn within their B Waypoint
			double legLength = currentLeg.getLength();
			double straightlength = legLength - (2 * COLLIDER_RADIUS); // the part of the leg where the ship sails on a straight line and speed can change
			double spd = t.getSpeedCap();
			if((spd > carryOverSpd) && (round > 1)){
				spd = carryOverSpd;
				t.setSpeedCap(spd);
			}
			double dist = 0;
			do{
				dist += spd * BROADCAST_INTERVAL;
				spd += decel * BROADCAST_INTERVAL;
				if(spd >= maxSpd){
					spd = maxSpd;
					break;
				}
			} while(dist < straightlength);
			carryOverSpd = spd;
		}
		// alternatively, the calculations of the first pass can be incorporated in the second loop, with rather minor modifications
	}
	
	public void run()
	{
		double speed = parameters.getInitialSpeed();
		//AISBroadcast ais;
		LinkedList<Leg> legs = route.getLegs();
		ListIterator<Leg> li = legs.listIterator();
		Leg firstLeg = legs.peek();
		Leg currentLeg;
		
		double vmax = vessel.getMaximumSpeed();
		double vmin = vessel.getMinimumSpeed();
		double acc = vessel.getAcceleration();
		Coordinates origin = firstLeg.getPointA();
		
		Azimuth bearing;
		Azimuth heading;
		double distanceToWaypoint;
		double distanceToApex;
		
		boolean firstStepOfArc = false;
		//boolean lastStepOfArc;
		Waypoint wb;
		
		// turn information. Initializations are arbitrary, to silence the compiler's "...might not have been initialized"
		Turn t;
		TurnDirection turnDirection = TurnDirection.RIGHT;
		Coordinates turnPoint = new Coordinates();
		double turnRadius = 0;
		double turnAngle;
		Coordinates turnEntryApex = new Coordinates();
		double turnCirclePerimeter = 0;
		//double arcStep;
		double angleStep = 0;
		Azimuth centralAngleAbsoluteAzm = new Azimuth();
		Coordinates positionFinder;
		double firstArcStep;
		double firstAngleStep;
		double turnAngleRemainder = 0;
		double step;
		double straightComponent;
		double curvedComponent;
		double slumberDuration;
		
		Coordinates position = new Coordinates(origin.getLongitude(), origin.getLatitude());
		
		// SYNCHRO POINT //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
		do{
			
			currentLeg = li.next();
			bearing = currentLeg.getCourse();
			heading = bearing;//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			
			// sail straight on Leg
			wb = (Waypoint)currentLeg.getPointB();
			do{
				broadcastAIS(position, heading, speed);
				distanceToWaypoint = Coordinates.calculateDistance(position, wb);
				distanceToApex = distanceToWaypoint - COLLIDER_RADIUS;
				System.out.println("distanceToWaypoint = " + distanceToWaypoint);///////////////////////////////////////////////////////////////////////////////////////////////////////////////
				//long tic = System.currentTimeMillis();
				
				speed += (vmax - speed) / vmax * acc; // speed up
				step = speed * (BROADCAST_INTERVAL / 1000); // conversion to seconds
				position.move(heading, step);
				//long toc = System.currentTimeMillis();
				//int timeTaken = (int)(toc - tic);
				//System.out.println("timeTaken: " + timeTaken + " milliseconds");
				sleep(BROADCAST_INTERVAL/* - timeTaken*/);
			} while(distanceToApex >= step);
			System.out.println("Waypoint !!");/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			
			// prepare for upcoming turn
			t = wb.getTurn();
			if(t == null){ // on last Leg
				// don't turn, just slow down to almost a stop, very close to destination
				do{
					broadcastAIS(position, heading, speed);
					distanceToWaypoint = Coordinates.calculateDistance(position, wb);
					System.out.println("distanceToWaypoint = " + distanceToWaypoint);//////////////////////////////////////////////////////////////////////////
					speed *= (distanceToWaypoint / COLLIDER_RADIUS);
					if(speed < vmin) speed = vmin;
					heading.turnTo(bearing, 0.95);
					step = speed * (BROADCAST_INTERVAL / 1000); // conversion to seconds
					position.move(heading, step);
					sleep(BROADCAST_INTERVAL);
				} while(distanceToWaypoint > DESTINATION_RADIUS);
			} else{
				// get turn details
				System.out.println("In turn !!");//////////////////////////////////////////////////////////////////////////////////////////////////////////////
				turnDirection = t.getTurnDirection();
				turnPoint = t.getTurnPoint();
				turnRadius = t.getTurnRadius();
				turnAngle = t.getTurnAngle();
				turnEntryApex = t.getTurnEntryApex();
				// calculate further turn information
				turnCirclePerimeter = 2 * Math.PI * turnRadius;
				angleStep = (step / turnCirclePerimeter) * 360;
				centralAngleAbsoluteAzm = Coordinates.calculateBearing(turnPoint, turnEntryApex);
				
				System.out.println("wb.toString()" + wb.toString());///////////////////////////////////////////////////////////////////////////////////////////
				System.out.println("currentLeg.getCourse()" + currentLeg.getCourse().getAzimuth());////////////////////////////////////////////////////////////
				System.out.println("turnEntryApex: " + turnEntryApex);/////////////////////////////////////////////////////////////////////////////////////////
				System.out.println("centralAngleAbsoluteAzm: " + centralAngleAbsoluteAzm.getAzimuth());////////////////////////////////////////////////////////
				
				firstStepOfArc = true;
				turnAngleRemainder = turnAngle;
				
				// take the turn
				do{
					if(firstStepOfArc){ // the fisrt fragment
						firstStepOfArc = false;
						// step == straightComponent + curvedComponent
						straightComponent = distanceToWaypoint - COLLIDER_RADIUS;
						curvedComponent = step - straightComponent;
						firstAngleStep = (curvedComponent / turnCirclePerimeter) * 360;
						turnAngleRemainder -= firstAngleStep;
						if(turnDirection == TurnDirection.LEFT){
							centralAngleAbsoluteAzm.rotateCounterClockwise(firstAngleStep);
							heading.rotateCounterClockwise(firstAngleStep);
						} else{
							centralAngleAbsoluteAzm.rotateClockwise(firstAngleStep);
							heading.rotateClockwise(firstAngleStep);
						}
					} else{
						turnAngleRemainder -= angleStep;
						if(turnDirection == TurnDirection.LEFT){
							centralAngleAbsoluteAzm.rotateCounterClockwise(angleStep);
							heading.rotateCounterClockwise(angleStep);
						} else{
							centralAngleAbsoluteAzm.rotateClockwise(angleStep);
							heading.rotateClockwise(angleStep);
						}
					}
					positionFinder = new Coordinates(turnPoint);
					positionFinder.move(centralAngleAbsoluteAzm, turnRadius);
					position = positionFinder;
					broadcastAIS(position, heading, speed);
					sleep(BROADCAST_INTERVAL);
				} while(turnAngleRemainder > angleStep);// turn completion criterion
				// last fragment
				System.out.println("angleStep" + angleStep);/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				System.out.println("turnAngleRemainder" + turnAngleRemainder);///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				if(turnDirection == TurnDirection.LEFT){
					centralAngleAbsoluteAzm.rotateCounterClockwise(turnAngleRemainder);
					heading.rotateCounterClockwise(turnAngleRemainder);
				} else{
					centralAngleAbsoluteAzm.rotateClockwise(turnAngleRemainder);
					heading.rotateClockwise(turnAngleRemainder);
				}
				positionFinder = new Coordinates(turnPoint);
				positionFinder.move(centralAngleAbsoluteAzm, turnRadius);
				position = positionFinder;
				broadcastAIS(position, heading, speed);
				slumberDuration = (turnAngleRemainder / angleStep * BROADCAST_INTERVAL);
				sleep((int)slumberDuration);
				turnAngleRemainder = 0;
				//aggressive mode ON //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			}
		} while(li.hasNext());
		System.out.println("Destination !!");/////////////////////////////////////////////////////////////////////////
		
		
		//Calculate speed limits for turns
		//firstPass();
		//secondPass();
		
		
		/*ListIterator<Waypoint> iterator = waypoints.listIterator();
		Coordinates position = iterator.next();
		Azimuth bearing;
		Waypoint nextWaypoint;
		double step, distanceToWaypoint, cap, legLength, waveHit;
		Random random = new Random(System.currentTimeMillis());
		while(iterator.hasNext()){
			nextWaypoint = iterator.next();
			System.out.println("Next waypoint is: (" + nextWaypoint.getLongitude() + ", " + nextWaypoint.getLatitude() + ")");//////////////////////////////////////////////////////////////
			bearing = Coordinates.calculateBearing(position, nextWaypoint);
			legLength = determineLegLength(iterator, nextWaypoint);
			System.out.println("LEG LENGTH: " + legLength);//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			cap = determineSpeedCap(iterator, nextWaypoint, bearing);
			System.out.println("CAP: " + cap);///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			do{
				distanceToWaypoint = Coordinates.calculateDistance(position, nextWaypoint);
				System.out.println("DISTANCE TO WAYPOINT: " + distanceToWaypoint);///////////////////////////////////////////////////////////////////////////////////////////////////////////
				//speed = 0.2;///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				determineSpeed(cap, distanceToWaypoint, legLength);
				
				
				// calculate a slightly randomized heading, take turbulence into account...
				waveHit = (random.nextInt(41) - 20) * turbulence;
				if(waveHit < 0){
					heading.rotateCounterClockwise(Math.abs(waveHit));
				} else{
					heading.rotateClockwise(waveHit);
				}
				
				//heading = bearing; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				step = speed * BROADCAST_INTERVAL / 1000;
				
				position.move(heading, step);
				bearing = Coordinates.calculateBearing(position, nextWaypoint);
				heading.turnTo(bearing, 0.8);
				AISBroadcast ais = new AISBroadcast(System.currentTimeMillis(), this.vessel, position, heading, speed);
				map.beep(ais);
				ais.toConsole();
				//don't forget to send to Esper
				
				try{
					Thread.sleep(BROADCAST_INTERVAL);
				} catch(InterruptedException ie){
					ie.printStackTrace();
				}
			}while(distanceToWaypoint > colliderRadius);
			System.out.println("Reached waypoint: (" + nextWaypoint.getLongitude() + ", " + nextWaypoint.getLatitude() + ")");
		}
		System.out.println("Reached destination.");*/
	}
	
	private void sleep(int milliseconds)
	{
		try{
			Thread.sleep(milliseconds);
		} catch(InterruptedException ie){
			ie.printStackTrace();
		}
	}
	
	private void broadcastAIS(Coordinates position, Azimuth heading, double speed)
	{
		AISBroadcast ais = new AISBroadcast(System.currentTimeMillis(), this.vessel, position, heading, speed);
		if(map != null) map.beep(ais);
		ais.toConsole();
	}
	
	/*private void firstPass()
	{
		ListIterator<Leg> legIterator = legs.listIterator();
		Leg currentLeg;
		Leg nextLeg;
		double maximumEntrySpeed;
		
		// First Pass
		currentLeg = legIterator.next();
		while(legIterator.hasNext()){
			nextLeg = legIterator.next();
			Azimuth currentCourse = currentLeg.getCourse();
			Azimuth nextCourse = nextLeg.getCourse();
			
			Azimuth relBearing = Azimuth.calculateRelativeBearing(currentCourse, nextCourse);
			double turn = relBearing.getAzimuth();
			if(turn > 180){
				turn = 360 - turn;
			}
			System.out.println("Next turn is angled: " + turn);//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			double speedCap = maxSpeed * (1 - (turn / 180));
			if(speedCap < minSpeed){
				speedCap = minSpeed;
			}
			currentLeg.getDestination().setSpeedCap(speedCap);
			currentLeg = nextLeg;
		}
		currentLeg.getDestination().setSpeedCap(minSpeed / 4);
		presentLegs();
		
		// Second Pass
		do{
			maximumEntrySpeed = currentLeg.getMaximumEntrySpeed(vessel.getDeceleration(), BROADCAST_INTERVAL);
			if(maximumEntrySpeed < currentLeg.getOrigin().getSpeedCap()){
				currentLeg.getOrigin().setSpeedCap(maximumEntrySpeed);
			}
			currentLeg = legIterator.previous();
		} while(legIterator.hasPrevious());
		presentLegs();
	}*/
	
	/*private double determineSpeedCap(ListIterator<Waypoint> iterator, Waypoint nextWaypoint, Azimuth currentBearing)
	{
		double speedCap;
		if(iterator.hasNext()){
			Waypoint waypointAfterTheNext = iterator.next();
			System.out.println("Upcoming waypoint beyond the next: LON " + waypointAfterTheNext.getLongitude() + " LAT " + waypointAfterTheNext.getLatitude());/////////////////////////////
			Azimuth nextBearing = Coordinates.calculateBearing(nextWaypoint, waypointAfterTheNext);
			double turn = Math.abs(nextBearing.getAzimuth() - currentBearing.getAzimuth());
			if(turn > 180){
				turn = 360 - turn;
			}
			System.out.println("Next turn is angled: " + turn);//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			speedCap = maxSpeed * (1 - (turn / 180));
			if(speedCap < minSpeed){
				speedCap = minSpeed;
			}
			iterator.previous(); //to reset the cursor position to the nextWaypoint
			return speedCap;
		} else{
			System.out.println("No waypoints beyond the next.");/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			speedCap = minSpeed * 1 / 3;
			return speedCap;
		}
	}*/
	
	/*private void determineSpeed(double cap, double distanceToWaypoint, double legLength)
	{
		double threshold = legLength * (1 - (cap / maxSpeed)) * 1.25;
		if(distanceToWaypoint < threshold){//if in braking radius
			System.out.println("IN BRAKING RADIUS");/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			convergeSpeedTo(cap, 0.06, 0.095);
		} else{
			convergeSpeedTo(maxSpeed, 0.06, 0.095);
		}
	}*/
	
	/*private void convergeSpeedTo(double target, double acceleration, double decceleration)
	{
		double diff = target - speed;
		if(diff > 0){
			speed += (diff) * acceleration;
		} else{
			speed += (diff) * decceleration;
		}
	}*/
	
	/*public void endTrip()
	{
		underWay = false;
	}*/
}