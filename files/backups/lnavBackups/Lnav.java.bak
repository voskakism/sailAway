import java.util.LinkedList;
import java.util.ListIterator;
import java.util.Random;
import com.espertech.esper.client.EPServiceProvider;

class Lnav implements Runnable
{
	//private boolean underWay = true;
	private final int BROADCAST_INTERVAL = AppConfiguration.getBroadcastInterval(); //milliseconds
	private final int COLLIDER_RADIUS = (AppConfiguration.getLaneWidth() / 2);
	private final int DESTINATION_RADIUS = 10;
	
	private Vessel vessel;
	private TripParameters parameters;
	private Itinerary route;
	private Terrain map;
	private EPServiceProvider engine;
	
	//Trip Info
	private Azimuth heading;
	private double speed;
	private double maxSpeed;
	private double minSpeed;
	private double laneWidth;
	private double turbulence;
	
	Lnav(Vessel vessel, TripParameters parameters, Itinerary route, Terrain map, EPServiceProvider engine)
	{
		//System.out.println("DEBUG: In Lnav Constructor");//////////////////////////////////////////////////////////////
		this.vessel = vessel;
		this.parameters = parameters;
		this.route = route;
		this.map = map;
		this.engine = engine;
	}
	
	public void run()
	{
		double speed = parameters.getInitialSpeed();
		//AISBroadcast ais;
		LinkedList<Leg> legs = route.getLegs();
		ListIterator<Leg> li = legs.listIterator();
		Leg firstLeg = legs.peek();
		Leg currentLeg;
		
		double vmax = vessel.getMaximumSpeed();
		double vmin = vessel.getMinimumSpeed();
		double acc = vessel.getAcceleration();
		Coordinates origin = firstLeg.getPointA();
		
		// move the mass calculation to constructor, for 1st / 2nd pass calculations of speed caps
		double weight = vessel.getWeight();
		double ballast = parameters.getBallast();
		double fuel = parameters.getFuel();
		double payload = parameters.getPayload();
		double mass = weight + ballast + fuel + payload; // assuming constant gravity acceleration (let g = 10 m/s^2) at sea level (at the Aegean and devoid of lunar tide), same weights correspond to equal masses.
		
		Azimuth bearing;
		Azimuth heading;
		double distanceToWaypoint;
		
		boolean firstStepOfArc = false;
		//boolean lastStepOfArc;
		Waypoint wb;
		
		// turn information. Initializations are arbitrary, to silence the compiler's "...might not have been initialized"
		Turn t;
		TurnDirection turnDirection = TurnDirection.RIGHT;
		Coordinates turnPoint = new Coordinates();
		double turnRadius = 0;
		double turnAngle;
		Coordinates turnEntryApex = new Coordinates();
		double turnCirclePerimeter = 0;
		//double arcStep;
		double angleStep = 0;
		Azimuth centralAngleAbsoluteAzm = new Azimuth();
		Coordinates positionFinder;
		double firstArcStep;
		double firstAngleStep;
		double turnAngleRemainder = 0;
		double step;
		double straightComponent;
		double curvedComponent;
		double slumberDuration;
		
		Coordinates position = new Coordinates(origin.getLongitude(), origin.getLatitude());
		
		do{
			
			currentLeg = li.next();
			bearing = currentLeg.getCourse();
			heading = bearing;//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			
			// sail straight on Leg
			wb = (Waypoint)currentLeg.getPointB();
			do{
				broadcastAIS(position, heading, speed);
				distanceToWaypoint = Coordinates.calculateDistance(position, wb);
				System.out.println("distanceToWaypoint = " + distanceToWaypoint);///////////////////////////////////////////////////////////////////////////////////////////////////////////////
				
				speed += (vmax - speed) / vmax * acc; // speed up
				step = speed * (BROADCAST_INTERVAL / 1000); // conversion to seconds
				position.move(heading, step);
				
				sleep(BROADCAST_INTERVAL);
			} while(distanceToWaypoint - COLLIDER_RADIUS >= step);
			System.out.println("Waypoint !!");/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			
			// prepare for upcoming turn
			t = wb.getTurn();
			if(t == null){ // on last Leg
				// don't turn, just slow down to almost a stop, very close to destination
				do{
					broadcastAIS(position, heading, speed);
					distanceToWaypoint = Coordinates.calculateDistance(position, wb);
					System.out.println("distanceToWaypoint = " + distanceToWaypoint);//////////////////////////////////////////////////////////////////////////
					speed *= (distanceToWaypoint / COLLIDER_RADIUS);
					if(speed < vmin) speed = vmin;
					heading.turnTo(bearing, 0.95);
					step = speed * (BROADCAST_INTERVAL / 1000); // conversion to seconds
					position.move(heading, step);
					sleep(BROADCAST_INTERVAL);
				} while(distanceToWaypoint > DESTINATION_RADIUS);
			} else{
				// get turn details
				System.out.println("In turn !!");//////////////////////////////////////////////////////////////////////////////////////////////////////////////
				turnDirection = t.getTurnDirection();
				turnPoint = t.getTurnPoint();
				turnRadius = t.getTurnRadius();
				turnAngle = t.getTurnAngle();
				turnEntryApex = t.getTurnEntryApex();
				// calculate further turn information
				turnCirclePerimeter = 2 * Math.PI * turnRadius;
				angleStep = (step / turnCirclePerimeter) * 360;
				centralAngleAbsoluteAzm = Coordinates.calculateBearing(turnPoint, turnEntryApex);
				
				System.out.println("wb.toString()" + wb.toString());///////////////////////////////////////////////////////////////////////////////////////////
				System.out.println("currentLeg.getCourse()" + currentLeg.getCourse().getAzimuth());////////////////////////////////////////////////////////////
				System.out.println("turnEntryApex: " + turnEntryApex);/////////////////////////////////////////////////////////////////////////////////////////
				System.out.println("centralAngleAbsoluteAzm: " + centralAngleAbsoluteAzm.getAzimuth());////////////////////////////////////////////////////////
				
				firstStepOfArc = true;
				turnAngleRemainder = turnAngle;
				
				// take the turn
				do{
					if(firstStepOfArc){ // the fisrt fragment
						firstStepOfArc = false;
						// step == straightComponent + curvedComponent
						straightComponent = distanceToWaypoint - COLLIDER_RADIUS;
						curvedComponent = step - straightComponent;
						firstAngleStep = (curvedComponent / turnCirclePerimeter) * 360;
						turnAngleRemainder -= firstAngleStep;
						if(turnDirection == TurnDirection.LEFT){
							centralAngleAbsoluteAzm.rotateCounterClockwise(firstAngleStep);
							heading.rotateCounterClockwise(firstAngleStep);
						} else{
							centralAngleAbsoluteAzm.rotateClockwise(firstAngleStep);
							heading.rotateClockwise(firstAngleStep);
						}
					} else{
						turnAngleRemainder -= angleStep;
						if(turnDirection == TurnDirection.LEFT){
							centralAngleAbsoluteAzm.rotateCounterClockwise(angleStep);
							heading.rotateCounterClockwise(angleStep);
						} else{
							centralAngleAbsoluteAzm.rotateClockwise(angleStep);
							heading.rotateClockwise(angleStep);
						}
					}
					positionFinder = new Coordinates(turnPoint);
					positionFinder.move(centralAngleAbsoluteAzm, turnRadius);
					position = positionFinder;
					broadcastAIS(position, heading, speed);
					sleep(BROADCAST_INTERVAL);
				} while(turnAngleRemainder > angleStep);// turn completion criterion
				// last fragment
				System.out.println("angleStep" + angleStep);/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				System.out.println("turnAngleRemainder" + turnAngleRemainder);///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				if(turnDirection == TurnDirection.LEFT){
					centralAngleAbsoluteAzm.rotateCounterClockwise(turnAngleRemainder);
					heading.rotateCounterClockwise(turnAngleRemainder);
				} else{
					centralAngleAbsoluteAzm.rotateClockwise(turnAngleRemainder);
					heading.rotateClockwise(turnAngleRemainder);
				}
				positionFinder = new Coordinates(turnPoint);
				positionFinder.move(centralAngleAbsoluteAzm, turnRadius);
				position = positionFinder;
				broadcastAIS(position, heading, speed);
				slumberDuration = (turnAngleRemainder / angleStep * BROADCAST_INTERVAL);
				sleep((int)slumberDuration);
				turnAngleRemainder = 0;
				//aggressive mode ON //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			}
		} while(li.hasNext());
		System.out.println("Destination !!");/////////////////////////////////////////////////////////////////////////
		
		
		//Calculate speed limits for turns
		//firstPass();
		//secondPass();
		
		
		/*ListIterator<Waypoint> iterator = waypoints.listIterator();
		Coordinates position = iterator.next();
		Azimuth bearing;
		Waypoint nextWaypoint;
		double step, distanceToWaypoint, cap, legLength, waveHit;
		Random random = new Random(System.currentTimeMillis());
		while(iterator.hasNext()){
			nextWaypoint = iterator.next();
			System.out.println("Next waypoint is: (" + nextWaypoint.getLongitude() + ", " + nextWaypoint.getLatitude() + ")");//////////////////////////////////////////////////////////////
			bearing = Coordinates.calculateBearing(position, nextWaypoint);
			legLength = determineLegLength(iterator, nextWaypoint);
			System.out.println("LEG LENGTH: " + legLength);//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			cap = determineSpeedCap(iterator, nextWaypoint, bearing);
			System.out.println("CAP: " + cap);///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			do{
				distanceToWaypoint = Coordinates.calculateDistance(position, nextWaypoint);
				System.out.println("DISTANCE TO WAYPOINT: " + distanceToWaypoint);///////////////////////////////////////////////////////////////////////////////////////////////////////////
				//speed = 0.2;///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				determineSpeed(cap, distanceToWaypoint, legLength);
				
				
				// calculate a slightly randomized heading, take turbulence into account...
				waveHit = (random.nextInt(41) - 20) * turbulence;
				if(waveHit < 0){
					heading.rotateCounterClockwise(Math.abs(waveHit));
				} else{
					heading.rotateClockwise(waveHit);
				}
				
				//heading = bearing; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				step = speed * BROADCAST_INTERVAL / 1000;
				
				position.move(heading, step);
				bearing = Coordinates.calculateBearing(position, nextWaypoint);
				heading.turnTo(bearing, 0.8);
				AISBroadcast ais = new AISBroadcast(System.currentTimeMillis(), this.vessel, position, heading, speed);
				map.beep(ais);
				ais.toConsole();
				//don't forget to send to Esper
				
				try{
					Thread.sleep(BROADCAST_INTERVAL);
				} catch(InterruptedException ie){
					ie.printStackTrace();
				}
			}while(distanceToWaypoint > colliderRadius);
			System.out.println("Reached waypoint: (" + nextWaypoint.getLongitude() + ", " + nextWaypoint.getLatitude() + ")");
		}
		System.out.println("Reached destination.");*/
	}
	
	private void sleep(int milliseconds)
	{
		try{
			Thread.sleep(milliseconds);
		} catch(InterruptedException ie){
			ie.printStackTrace();
		}
	}
	
	private void broadcastAIS(Coordinates position, Azimuth heading, double speed)
	{
		AISBroadcast ais = new AISBroadcast(System.currentTimeMillis(), this.vessel, position, heading, speed);
		if(map != null) map.beep(ais);
		ais.toConsole();
	}
	
	/*private void firstPass()
	{
		ListIterator<Leg> legIterator = legs.listIterator();
		Leg currentLeg;
		Leg nextLeg;
		double maximumEntrySpeed;
		
		// First Pass
		currentLeg = legIterator.next();
		while(legIterator.hasNext()){
			nextLeg = legIterator.next();
			Azimuth currentCourse = currentLeg.getCourse();
			Azimuth nextCourse = nextLeg.getCourse();
			
			Azimuth relBearing = Azimuth.calculateRelativeBearing(currentCourse, nextCourse);
			double turn = relBearing.getAzimuth();
			if(turn > 180){
				turn = 360 - turn;
			}
			System.out.println("Next turn is angled: " + turn);//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			double speedCap = maxSpeed * (1 - (turn / 180));
			if(speedCap < minSpeed){
				speedCap = minSpeed;
			}
			currentLeg.getDestination().setSpeedCap(speedCap);
			currentLeg = nextLeg;
		}
		currentLeg.getDestination().setSpeedCap(minSpeed / 4);
		presentLegs();
		
		// Second Pass
		do{
			maximumEntrySpeed = currentLeg.getMaximumEntrySpeed(vessel.getDeceleration(), BROADCAST_INTERVAL);
			if(maximumEntrySpeed < currentLeg.getOrigin().getSpeedCap()){
				currentLeg.getOrigin().setSpeedCap(maximumEntrySpeed);
			}
			currentLeg = legIterator.previous();
		} while(legIterator.hasPrevious());
		presentLegs();
	}*/
	
	/*private double determineSpeedCap(ListIterator<Waypoint> iterator, Waypoint nextWaypoint, Azimuth currentBearing)
	{
		double speedCap;
		if(iterator.hasNext()){
			Waypoint waypointAfterTheNext = iterator.next();
			System.out.println("Upcoming waypoint beyond the next: LON " + waypointAfterTheNext.getLongitude() + " LAT " + waypointAfterTheNext.getLatitude());/////////////////////////////
			Azimuth nextBearing = Coordinates.calculateBearing(nextWaypoint, waypointAfterTheNext);
			double turn = Math.abs(nextBearing.getAzimuth() - currentBearing.getAzimuth());
			if(turn > 180){
				turn = 360 - turn;
			}
			System.out.println("Next turn is angled: " + turn);//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			speedCap = maxSpeed * (1 - (turn / 180));
			if(speedCap < minSpeed){
				speedCap = minSpeed;
			}
			iterator.previous(); //to reset the cursor position to the nextWaypoint
			return speedCap;
		} else{
			System.out.println("No waypoints beyond the next.");/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			speedCap = minSpeed * 1 / 3;
			return speedCap;
		}
	}*/
	
	/*private void determineSpeed(double cap, double distanceToWaypoint, double legLength)
	{
		double threshold = legLength * (1 - (cap / maxSpeed)) * 1.25;
		if(distanceToWaypoint < threshold){//if in braking radius
			System.out.println("IN BRAKING RADIUS");/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			convergeSpeedTo(cap, 0.06, 0.095);
		} else{
			convergeSpeedTo(maxSpeed, 0.06, 0.095);
		}
	}*/
	
	/*private void convergeSpeedTo(double target, double acceleration, double decceleration)
	{
		double diff = target - speed;
		if(diff > 0){
			speed += (diff) * acceleration;
		} else{
			speed += (diff) * decceleration;
		}
	}*/
	
	/*public void endTrip()
	{
		underWay = false;
	}*/
}