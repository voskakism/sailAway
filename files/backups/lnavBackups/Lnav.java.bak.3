import java.util.LinkedList;
import java.util.ListIterator;
import java.util.Iterator;
import java.util.Random;
import com.espertech.esper.client.EPServiceProvider;

class Lnav implements Runnable
{
	//private boolean underWay = true;
	private final int BROADCAST_INTERVAL = AppConfiguration.getBroadcastInterval(); //milliseconds
	private final int COLLIDER_RADIUS = (AppConfiguration.getLaneWidth() / 2);
	private final int DESTINATION_RADIUS = 10;
	//private final double SPEED_TOLERANCE = 0.5;/////////////////////////////////////////////////////////////////////////////////
	
	private Vessel vessel;
	private TripParameters parameters;
	private Itinerary route;
	private Terrain map;
	private EPServiceProvider engine;
	
	//Trip Info
	private Azimuth heading;
	private double speed;
	private double maxSpeed;
	private double minSpeed;
	private double laneWidth;
	private double turbulence;
	
	Lnav(Vessel vessel, TripParameters parameters, Itinerary route, Terrain map, EPServiceProvider engine)
	{
		//System.out.println("DEBUG: In Lnav Constructor");//////////////////////////////////////////////////////////////
		this.vessel = vessel;
		this.parameters = parameters;
		this.route = route;
		this.map = map;
		this.engine = engine;
		
		// total mass calculation
		double weight = vessel.getWeight();
		double ballast = parameters.getBallast();
		double fuel = parameters.getFuel();
		double payload = parameters.getPayload();
		double mass = weight + ballast + fuel + payload; // assuming constant gravity acceleration (let g = 10 m/s^2) at sea level (at the Aegean and devoid of lunar tide), same weights correspond to equal masses.
		//System.out.println("mass: " + mass);/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// set speed caps for turns.
		LinkedList<Leg> legs = route.getLegs();
		ListIterator<Leg> li = legs.listIterator();
		// 1st pass: calculate speed limits of each turn 'myopically' based the turn alone.
		// The ships follow uniform circular motion when taking a turn. Consequently, angular acceleration is zero, angular velocity, speed (linear, tangential), circle's center (a.k.a. "turnpoint") and turn radius are all constant for each turn.
		// In such motion, the formula for centripetal acceleration is given by: ac = v^2 / r , where: ac = centripetal acceleration, v = speed, r = turn radius. Multiplying the equation with mass,
		// Fc  = v^2 * m / r , where Fc = centripetal force, m = mass (Newton's 2nd Law of Motion). We solve for speed. Fc is an app-wide extra-systemic constant.
		// The speed limit refers to the (maximum for the turn) linear speed of the ship and it is as a scalar, not a vector.
		double centripetalForce = AppConfiguration.getCentripetalForce(); /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		do{
			Leg currentLeg = li.next();
			Waypoint wb = (Waypoint)currentLeg.getPointB();
			Turn t = wb.getTurn();
			if(t == null) continue;
			double turnRadius = t.getTurnRadius();
			double cap = Math.sqrt(centripetalForce * turnRadius / mass);
			//double cap = Math.sqrt(10 * turnRadius / 214);//////////////////////////////////////////////////////////////////////////////////////
			t.setSpeedCap(cap);
		} while(li.hasNext());
		System.out.println("1st pass caps:");///////////////////////////////////////////////////////////////////
		for(int i = 0; i < route.getLegs().size() - 1; i++){
			Waypoint bb = (Waypoint)route.getLegs().get(i).getPointB();
			System.out.println(bb.getTurn().getSpeedCap());
		}
		// 2nd pass: where needed, update the speed limits of turns so that they take into consideration the speed limits of other turns ahead that are very close, as in an "S" pair of turns.
		// Starting from the last turn (that is the B point of the next-to-last Leg; Note that the process of slowing down to an almost stop at destination is quite different),
		// we get the speed limit calculated earlier and perform a "reverse counting" procedure, where moving backwards on the leg, we re-create the ship's steps on it as it could possibly decelerate before the turn.
		// In each iteration (backstep), we calculate the covered distance and speed, in a reverse fashion (that is, increasing the speed as we move in reverse, in the same rate that the forward-moving
		// ship would reduce it). The "counting" stops when we reach the begining of the leg at collider radius distance (since that is the closest to the begining of the Leg where speed can change),
		// OR if the speed "count" reaches the vessels max speed. In any case, the speed found, is compared to the speed limit of point B of the previous Leg (the previous Turn) if there is one.
		// If the previous turn's limit is higher than the speed "count", a.k.a. "carryOver", it is replaced by it. Obviously, the count for the next Leg starts from the (possibly) updated speed limit.
		// It is also apparent that if carryOver reaches max speed, it cannot affect the speed limit of the previous turn.
		// In a cascading manner, the "carried over" speed limit updates the speed caps (if needed), all the way to the beginning of the trip.
		double carryOverSpd = -1;
		int round = 0;
		double decel = vessel.getDeceleration();
		double maxSpd = vessel.getMaximumSpeed();
		Iterator<Leg> di = legs.descendingIterator(); // REVERSE iterator: The first element to be gotten here, is the route's last leg
		di.next(); // skip last leg, it has no Turn, just the destination of the trip
		while(di.hasNext()){
			round++;
			Leg currentLeg = di.next();
			Waypoint wb = (Waypoint)currentLeg.getPointB();
			Turn t = wb.getTurn();
			if(t == null) break; // unlikely. all Legs but the last have a Turn within their B Waypoint
			double legLength = currentLeg.getLength();
			double straightlength = legLength - (2 * COLLIDER_RADIUS); // the part of the leg where the ship sails on a straight line and speed can change
			double spd = t.getSpeedCap();
			if((spd > carryOverSpd) && (round > 1)){ // skip last turn (round == 1), as there is no carryOverSpd to compare it against.
				spd = carryOverSpd;
				t.setSpeedCap(spd);
			}
			double dist = 0;
			do{
				dist += spd * (BROADCAST_INTERVAL / 1000);
				spd += decel * (BROADCAST_INTERVAL / 1000);
				if(spd >= maxSpd){
					spd = maxSpd;
					currentLeg.setCheckSpeedDistance(dist);
					break;
				}
			} while(dist <= straightlength);
			carryOverSpd = spd;
		}
		
		System.out.println("2nd pass caps:");///////////////////////////////////////////////////////////////////
		for(int i = 0; i < route.getLegs().size() - 1; i++){
			Waypoint bb = (Waypoint)route.getLegs().get(i).getPointB();
			System.out.println(bb.getTurn().getSpeedCap());
		}
		
		// alternatively, the calculations of the first pass can be incorporated in the second loop, with rather minor modifications
	}
	
	public void run()
	{
		double speed = parameters.getInitialSpeed();
		//AISBroadcast ais;
		LinkedList<Leg> legs = route.getLegs();
		ListIterator<Leg> li = legs.listIterator();
		Leg firstLeg = legs.peek();
		Leg currentLeg;
		
		double vmax = vessel.getMaximumSpeed();
		double vmin = vessel.getMinimumSpeed();
		double acc = vessel.getAcceleration();
		Coordinates origin = firstLeg.getPointA();
		
		Azimuth bearing;
		Azimuth heading;
		double distanceToWaypoint;
		double distanceToApex;
		
		boolean firstStepOfArc = false;
		//boolean lastStepOfArc;
		Waypoint wb;
		
		// turn information. Initializations are arbitrary, to silence the compiler's "...might not have been initialized"
		Turn t;
		TurnDirection turnDirection = TurnDirection.RIGHT;
		Coordinates turnPoint = new Coordinates();
		double turnRadius = 0;
		double turnAngle;
		Coordinates turnEntryApex = new Coordinates();
		double turnCirclePerimeter = 0;
		//double arcStep;
		double angleStep = 0;
		Azimuth centralAngleAbsoluteAzm = new Azimuth();
		Coordinates positionFinder;
		double firstArcStep;
		double firstAngleStep;
		double turnAngleRemainder = 0;
		double step;
		double straightComponent;
		double curvedComponent;
		double slumberDuration;
		
		Coordinates position = new Coordinates(origin.getLongitude(), origin.getLatitude());
		
		// SYNCHRO POINT ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/*Threadcount++;
		lock.wait();
		when App.main gets the full count of threads, then it:
		notifyAll();*/
		do{
			
			currentLeg = li.next();
			bearing = currentLeg.getCourse();
			heading = bearing;//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			
			// sail straight on Leg
			wb = (Waypoint)currentLeg.getPointB();
			do{
				//long tic = System.currentTimeMillis();
				broadcastAIS(position, heading, speed);
				distanceToWaypoint = Coordinates.calculateDistance(position, wb);
				distanceToApex = distanceToWaypoint - COLLIDER_RADIUS;
				System.out.println("distanceToWaypoint = " + distanceToWaypoint);///////////////////////////////////////////////////////////////////////////////////////////////////////////////
				
				
				
				speed += ((vmax - speed) / vmax * acc) * (BROADCAST_INTERVAL / 1000); // speed up
				step = speed * (BROADCAST_INTERVAL / 1000); // conversion to seconds
				position.move(heading, step);
				
				
				
				//long toc = System.currentTimeMillis();
				//int timeTaken = (int)(toc - tic);
				//System.out.println("timeTaken: " + timeTaken + " milliseconds");
				sleep(BROADCAST_INTERVAL/* - timeTaken*/);
			} while(distanceToApex >= step);
			System.out.println("Waypoint !!");/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			
			// prepare for upcoming turn
			t = wb.getTurn();
			if(t == null){ // on last Leg
				// don't turn, just slow down to almost a stop, very close to destination
				do{
					broadcastAIS(position, heading, speed);
					distanceToWaypoint = Coordinates.calculateDistance(position, wb);
					System.out.println("distanceToWaypoint = " + distanceToWaypoint);//////////////////////////////////////////////////////////////////////////
					speed *= (distanceToWaypoint / COLLIDER_RADIUS);
					if(speed < vmin) speed = vmin;
					heading.turnTo(bearing, 0.95);
					step = speed * (BROADCAST_INTERVAL / 1000); // conversion to seconds
					position.move(heading, step);
					sleep(BROADCAST_INTERVAL);
				} while(distanceToWaypoint > DESTINATION_RADIUS);
			} else{
				// get turn details
				System.out.println("In turn !!");//////////////////////////////////////////////////////////////////////////////////////////////////////////////
				turnDirection = t.getTurnDirection();
				turnPoint = t.getTurnPoint();
				turnRadius = t.getTurnRadius();
				turnAngle = t.getTurnAngle();
				turnEntryApex = t.getTurnEntryApex();
				// calculate further turn information
				turnCirclePerimeter = 2 * Math.PI * turnRadius;
				angleStep = (step / turnCirclePerimeter) * 360;
				centralAngleAbsoluteAzm = Coordinates.calculateBearing(turnPoint, turnEntryApex);
				
				System.out.println("wb.toString()" + wb.toString());///////////////////////////////////////////////////////////////////////////////////////////
				System.out.println("currentLeg.getCourse()" + currentLeg.getCourse().getAzimuth());////////////////////////////////////////////////////////////
				System.out.println("turnEntryApex: " + turnEntryApex);/////////////////////////////////////////////////////////////////////////////////////////
				System.out.println("centralAngleAbsoluteAzm: " + centralAngleAbsoluteAzm.getAzimuth());////////////////////////////////////////////////////////
				
				System.out.println("turnCirclePerimeter: " + turnCirclePerimeter);////////////////////////////////////////////////////////
				
				firstStepOfArc = true;
				turnAngleRemainder = turnAngle;
				
				// take the turn
				do{
					if(firstStepOfArc){ // the fisrt fragment
						firstStepOfArc = false;
						straightComponent = distanceToWaypoint - COLLIDER_RADIUS; // OR just = distanceToApex ?// step == straightComponent + curvedComponent
						curvedComponent = step - straightComponent;
						firstAngleStep = (curvedComponent / turnCirclePerimeter) * 360;
						System.out.println("firstAngleStep: " + firstAngleStep);////////////////////////////////////////////////////////////////
						turnAngleRemainder -= firstAngleStep;
						if(turnDirection == TurnDirection.LEFT){
							centralAngleAbsoluteAzm.rotateCounterClockwise(firstAngleStep);
							heading.rotateCounterClockwise(firstAngleStep);
						} else{
							centralAngleAbsoluteAzm.rotateClockwise(firstAngleStep);
							heading.rotateClockwise(firstAngleStep);
						}
					} else{
						System.out.println("angleStep: " + angleStep);////////////////////////////////////////////////////////////////
						turnAngleRemainder -= angleStep;
						if(turnDirection == TurnDirection.LEFT){
							centralAngleAbsoluteAzm.rotateCounterClockwise(angleStep);
							heading.rotateCounterClockwise(angleStep);
						} else{
							centralAngleAbsoluteAzm.rotateClockwise(angleStep);
							heading.rotateClockwise(angleStep);
						}
					}
					positionFinder = new Coordinates(turnPoint);
					positionFinder.move(centralAngleAbsoluteAzm, turnRadius);
					position = positionFinder;
					broadcastAIS(position, heading, speed);
					sleep(BROADCAST_INTERVAL);
				} while(turnAngleRemainder > angleStep);// turn completion criterion
				// last fragment
				System.out.println("angleStep" + angleStep);/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				System.out.println("turnAngleRemainder" + turnAngleRemainder);///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				if(turnDirection == TurnDirection.LEFT){
					centralAngleAbsoluteAzm.rotateCounterClockwise(turnAngleRemainder);
					heading.rotateCounterClockwise(turnAngleRemainder);
				} else{
					centralAngleAbsoluteAzm.rotateClockwise(turnAngleRemainder);
					heading.rotateClockwise(turnAngleRemainder);
				}
				positionFinder = new Coordinates(turnPoint);
				positionFinder.move(centralAngleAbsoluteAzm, turnRadius);
				position = positionFinder;
				broadcastAIS(position, heading, speed);
				//slumberDuration = (turnAngleRemainder / angleStep * BROADCAST_INTERVAL);
				//sleep((int)slumberDuration);
				turnAngleRemainder = 0;
				//aggressive mode ON //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			}
		} while(li.hasNext());
		System.out.println("Destination !!");/////////////////////////////////////////////////////////////////////////
		
		
		//Calculate speed limits for turns
		//firstPass();
		//secondPass();
		
		
		/*ListIterator<Waypoint> iterator = waypoints.listIterator();
		Coordinates position = iterator.next();
		Azimuth bearing;
		Waypoint nextWaypoint;
		double step, distanceToWaypoint, cap, legLength, waveHit;
		Random random = new Random(System.currentTimeMillis());
		while(iterator.hasNext()){
			nextWaypoint = iterator.next();
			System.out.println("Next waypoint is: (" + nextWaypoint.getLongitude() + ", " + nextWaypoint.getLatitude() + ")");//////////////////////////////////////////////////////////////
			bearing = Coordinates.calculateBearing(position, nextWaypoint);
			legLength = determineLegLength(iterator, nextWaypoint);
			System.out.println("LEG LENGTH: " + legLength);//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			cap = determineSpeedCap(iterator, nextWaypoint, bearing);
			System.out.println("CAP: " + cap);///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			do{
				distanceToWaypoint = Coordinates.calculateDistance(position, nextWaypoint);
				System.out.println("DISTANCE TO WAYPOINT: " + distanceToWaypoint);///////////////////////////////////////////////////////////////////////////////////////////////////////////
				//speed = 0.2;///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				determineSpeed(cap, distanceToWaypoint, legLength);
				
				
				// calculate a slightly randomized heading, take turbulence into account...
				waveHit = (random.nextInt(41) - 20) * turbulence;
				if(waveHit < 0){
					heading.rotateCounterClockwise(Math.abs(waveHit));
				} else{
					heading.rotateClockwise(waveHit);
				}
				
				//heading = bearing; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				step = speed * BROADCAST_INTERVAL / 1000;
				
				position.move(heading, step);
				bearing = Coordinates.calculateBearing(position, nextWaypoint);
				heading.turnTo(bearing, 0.8);
				AISBroadcast ais = new AISBroadcast(System.currentTimeMillis(), this.vessel, position, heading, speed);
				map.beep(ais);
				ais.toConsole();
				//don't forget to send to Esper
				
				try{
					Thread.sleep(BROADCAST_INTERVAL);
				} catch(InterruptedException ie){
					ie.printStackTrace();
				}
			}while(distanceToWaypoint > colliderRadius);
			System.out.println("Reached waypoint: (" + nextWaypoint.getLongitude() + ", " + nextWaypoint.getLatitude() + ")");
		}
		System.out.println("Reached destination.");*/
	}
	
	private void sleep(int milliseconds)
	{
		try{
			Thread.sleep(milliseconds);
		} catch(InterruptedException ie){
			ie.printStackTrace();
		}
	}
	
	private void broadcastAIS(Coordinates position, Azimuth heading, double speed)
	{
		AISBroadcast ais = new AISBroadcast(System.currentTimeMillis(), this.vessel, position, heading, speed);
		engine.getEPRuntime().sendEvent(ais);
		if(map != null) map.beep(ais);
		ais.toConsole();
	}
	
	/*private void firstPass()
	{
		ListIterator<Leg> legIterator = legs.listIterator();
		Leg currentLeg;
		Leg nextLeg;
		double maximumEntrySpeed;
		
		// First Pass
		currentLeg = legIterator.next();
		while(legIterator.hasNext()){
			nextLeg = legIterator.next();
			Azimuth currentCourse = currentLeg.getCourse();
			Azimuth nextCourse = nextLeg.getCourse();
			
			Azimuth relBearing = Azimuth.calculateRelativeBearing(currentCourse, nextCourse);
			double turn = relBearing.getAzimuth();
			if(turn > 180){
				turn = 360 - turn;
			}
			System.out.println("Next turn is angled: " + turn);//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			double speedCap = maxSpeed * (1 - (turn / 180));
			if(speedCap < minSpeed){
				speedCap = minSpeed;
			}
			currentLeg.getDestination().setSpeedCap(speedCap);
			currentLeg = nextLeg;
		}
		currentLeg.getDestination().setSpeedCap(minSpeed / 4);
		presentLegs();
		
		// Second Pass
		do{
			maximumEntrySpeed = currentLeg.getMaximumEntrySpeed(vessel.getDeceleration(), BROADCAST_INTERVAL);
			if(maximumEntrySpeed < currentLeg.getOrigin().getSpeedCap()){
				currentLeg.getOrigin().setSpeedCap(maximumEntrySpeed);
			}
			currentLeg = legIterator.previous();
		} while(legIterator.hasPrevious());
		presentLegs();
	}*/
	
	/*private double determineSpeedCap(ListIterator<Waypoint> iterator, Waypoint nextWaypoint, Azimuth currentBearing)
	{
		double speedCap;
		if(iterator.hasNext()){
			Waypoint waypointAfterTheNext = iterator.next();
			System.out.println("Upcoming waypoint beyond the next: LON " + waypointAfterTheNext.getLongitude() + " LAT " + waypointAfterTheNext.getLatitude());/////////////////////////////
			Azimuth nextBearing = Coordinates.calculateBearing(nextWaypoint, waypointAfterTheNext);
			double turn = Math.abs(nextBearing.getAzimuth() - currentBearing.getAzimuth());
			if(turn > 180){
				turn = 360 - turn;
			}
			System.out.println("Next turn is angled: " + turn);//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			speedCap = maxSpeed * (1 - (turn / 180));
			if(speedCap < minSpeed){
				speedCap = minSpeed;
			}
			iterator.previous(); //to reset the cursor position to the nextWaypoint
			return speedCap;
		} else{
			System.out.println("No waypoints beyond the next.");/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			speedCap = minSpeed * 1 / 3;
			return speedCap;
		}
	}*/
	
	/*private void determineSpeed(double cap, double distanceToWaypoint, double legLength)
	{
		double threshold = legLength * (1 - (cap / maxSpeed)) * 1.25;
		if(distanceToWaypoint < threshold){//if in braking radius
			System.out.println("IN BRAKING RADIUS");/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			convergeSpeedTo(cap, 0.06, 0.095);
		} else{
			convergeSpeedTo(maxSpeed, 0.06, 0.095);
		}
	}*/
	
	/*private void convergeSpeedTo(double target, double acceleration, double decceleration)
	{
		double diff = target - speed;
		if(diff > 0){
			speed += (diff) * acceleration;
		} else{
			speed += (diff) * decceleration;
		}
	}*/
	
	/*public void endTrip()
	{
		underWay = false;
	}*/
}